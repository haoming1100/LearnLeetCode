### 散列表
散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。
也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，
这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

> 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建
小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定
下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，
或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入
域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

![Alt text](https://upload.wikimedia.org/wikipedia/commons/d/da/Hash_function.svg)

一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表
（即建立人名 x 到首字母 F(x)的一个函数关系），
在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，
“取首字母”是这个例子中散列函数的函数法则  F()，存放首字母的表对应
散列表。关键字和函数法则理论上可以任意确定。``

---
- 散列表
    - 若关键字为 k，则其值存放在 f(k)的存储位置上。
    由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。
    
- 散列冲突
    - 对不同的 key 可能计算得到相同的值，这种想象就被称之为散列冲突。具有相同的函数值的 key
    对这个散列函数来说就叫做同义词。遇到了冲突就要解决冲突，就跟 Java 中的 try catch 一样。
    
    
- 散列地址
    - 根据散列函数将一组关键字 映射到某一有限连续地址中，key 作为索引，这种表就叫做散列表。
    这一过程就叫做 散列。某一有限连续地址就是散列地址
    
- 均匀散列函数
    - 就是在散列函数中，把任何一个关键字散列到任何一个地址的概率是相等的，我们称之为均匀散列函数
    
---
### 常用的散列函数

散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。

- 直接定址法：取关键字或关键字的某个线性函数值为散列地址。即 hash(k)=k或  hash(k)=a * k + b，其中  a,b为常数（这种散列函数叫做自身函数）
- 数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
- 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
- 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。
- 随机数法
- 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即  hash(k)=k mod p, p <= m。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。

---
### 冲突解决

- 开放定址法
- 单独链表法 （比如可以按 redis 的 zset 理解，不过redis 的zset 是双端链表）
    >将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。
- 双散列。
- 再散列
- 建立一个公共溢出区

---
### 查找效率
散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找

查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：

-   散列函数是否均匀；
- 处理冲突的方法；
- 散列表的载荷因子（英语：load factor）

> ###载荷因子

>散列表的载荷因子定义为： a  = 填入表中的元素个数 / 散列表的长度

> a 是散列表装满程度的标志因子。由于表长是定值， a 与“填入表中的元素个数”成正比，所以， a 越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之， a 越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子 a 的函数，只是不同处理冲突的方法有不同的函数。

> 对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。

